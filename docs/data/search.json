{"list":[{"title":"Bucket","link":"<a href=\"Bucket.html\">Bucket</a>"},{"title":"Bucket#getClosestToKey","link":"<a href=\"Bucket.html#getClosestToKey\">getClosestToKey</a>","description":"<p>Returns an array of contacts in the bucket that are closest to the given\nkey</p>"},{"title":"Bucket#head","link":"<a href=\"Bucket.html#head\">head</a>"},{"title":"Bucket#indexOf","link":"<a href=\"Bucket.html#indexOf\">indexOf</a>","description":"<p>Returns the index of the given node id</p>"},{"title":"Bucket#length","link":"<a href=\"Bucket.html#length\">length</a>"},{"title":"Bucket#set","link":"<a href=\"Bucket.html#set\">set</a>","description":"<p>Sets the contact to the node ID in the bucket if it is not full; if the\nbucket already contains the contact, move it to the tail - otherwise we\nplace it at the head</p>"},{"title":"Bucket#tail","link":"<a href=\"Bucket.html#tail\">tail</a>"},{"title":"ContactList#active","link":"<a href=\"ContactList.html#active\">active</a>"},{"title":"ContactList#add","link":"<a href=\"ContactList.html#add\">add</a>","description":"<p>Adds the given contacts to the list</p>"},{"title":"ContactList#closest","link":"<a href=\"ContactList.html#closest\">closest</a>"},{"title":"ContactList#contacted","link":"<a href=\"ContactList.html#contacted\">contacted</a>","description":"<p>Marks the supplied contact as contacted</p>"},{"title":"ContactList#responded","link":"<a href=\"ContactList.html#responded\">responded</a>","description":"<p>Marks the supplied contact as active</p>"},{"title":"ContactList#uncontacted","link":"<a href=\"ContactList.html#uncontacted\">uncontacted</a>"},{"title":"Node","link":"<a href=\"Node.html\">Node</a>"},{"title":"Node#expire","link":"<a href=\"Node.html#expire\">expire</a>","description":"<p>Items expire T_EXPIRE seconds after the original publication. All items\nare assigned an expiration time which is &quot;exponentially inversely\nproportional to the number of nodes between the current node and the node\nwhose ID is closest to the key&quot;, where this number is &quot;inferred from the\nbucket structure of the current node&quot;.</p>"},{"title":"Node#iterativeFindNode","link":"<a href=\"Node.html#iterativeFindNode\">iterativeFindNode</a>","description":"<p>Basic kademlia lookup operation that builds a set of K contacts closest\nto the given key</p>"},{"title":"Node#iterativeFindValue","link":"<a href=\"Node.html#iterativeFindValue\">iterativeFindValue</a>","description":"<p>Kademlia search operation that is conducted as a node lookup and builds\na list of K closest contacts. If at any time during the lookup the value\nis returned, the search is abandoned. If no value is found, the K closest\ncontacts are returned. Upon success, we must store the value at the\nnearest node seen during the search that did not return the value.</p>"},{"title":"Node#iterativeStore","link":"<a href=\"Node.html#iterativeStore\">iterativeStore</a>","description":"<p>Performs a {@link Node#iterativeFindNode} to collect K contacts\nnearest to the given key, sending a STORE message to each of them.</p>"},{"title":"Node#join","link":"<a href=\"Node.html#join\">join</a>","description":"<p>Inserts the given contact into the routing table and uses it to perform\na {@link Node#iterativeFindNode} for this node's identity,\nthen refreshes all buckets further than it's closest neighbor, which will\nbe in the occupied bucket with the lowest index</p>"},{"title":"Node#ping","link":"<a href=\"Node.html#ping\">ping</a>","description":"<p>Sends a PING message to the supplied contact, resolves with latency</p>"},{"title":"Node#refresh","link":"<a href=\"Node.html#refresh\">refresh</a>","description":"<p>If no node lookups have been performed in any given bucket's range for\nT_REFRESH, the node selects a random number in that range and does a\nrefresh, an iterativeFindNode using that number as key.</p>"},{"title":"Node#replicate","link":"<a href=\"Node.html#replicate\">replicate</a>","description":"<p>Performs a scan of the storage adapter and performs\nrepublishing/replication of items stored. Items that we did not publish\nourselves get republished every T_REPLICATE. Items we did publish get\nrepublished every T_REPUBLISH.</p>"},{"title":"Node~iterativeStoreCallback","link":"<a href=\"Node.html#~iterativeStoreCallback\">iterativeStoreCallback</a>","description":"<p>Note that if there is a protocol/validation error, you will not receive\nit as an error in the callback. Be sure to also check that stored &gt; 0 as\npart of error handling here.</p>"},{"title":"Protocol","link":"<a href=\"Protocol.html\">Protocol</a>"},{"title":"Protocol#FIND_NODE","link":"<a href=\"Protocol.html#FIND_NODE\">FIND_NODE</a>","description":"<p>The FIND_NODE RPC includes a 160-bit key. The recipient of the RPC returns\nup to K contacts that it knows to be closest to the key. The recipient\nmust return K contacts if at all possible. It may only return fewer than K\nif it is returning all of the contacts that it has knowledge of.</p>"},{"title":"Protocol#FIND_VALUE","link":"<a href=\"Protocol.html#FIND_VALUE\">FIND_VALUE</a>","description":"<p>A FIND_VALUE RPC includes a B=160-bit key. If a corresponding value is\npresent on the recipient, the associated data is returned. Otherwise the\nRPC is equivalent to a FIND_NODE and a set of K contacts is returned.</p>"},{"title":"Protocol#PING","link":"<a href=\"Protocol.html#PING\">PING</a>","description":"<p>This RPC involves one node sending a PING message to another, which\npresumably replies with a PONG. This has a two-fold effect: the\nrecipient of the PING must update the bucket corresponding to the\nsender; and, if there is a reply, the sender must update the bucket\nappropriate to the recipient.</p>"},{"title":"Protocol#STORE","link":"<a href=\"Protocol.html#STORE\">STORE</a>","description":"<p>The sender of the STORE RPC provides a key and a block of data and\nrequires that the recipient store the data and make it available for\nlater retrieval by that key.</p>"},{"title":"Router","link":"<a href=\"Router.html\">Router</a>","description":"<p>Constructs a routing table</p>"},{"title":"Router#addContactByNodeId","link":"<a href=\"Router.html#addContactByNodeId\">addContactByNodeId</a>","description":"<p>Adds the contact to the routing table in the proper bucket position,\nreturning the [bucketIndex, bucket, contactIndex, contact]; if the\nreturned contactIndex is -1, it indicates the bucket is full and the\ncontact was not added; kademlia implementations should PING the contact\nat bucket.head to determine if it should be dropped before calling this\nmethod again</p>"},{"title":"Router#getClosestBucket","link":"<a href=\"Router.html#getClosestBucket\">getClosestBucket</a>","description":"<p>Returns the [index, bucket] of the occupied bucket with the lowest index</p>"},{"title":"Router#getClosestContactsToKey","link":"<a href=\"Router.html#getClosestContactsToKey\">getClosestContactsToKey</a>","description":"<p>Returns a array of N contacts closest to the supplied key</p>"},{"title":"Router#getContactByNodeId","link":"<a href=\"Router.html#getContactByNodeId\">getContactByNodeId</a>","description":"<p>Returns the contact object associated with the given node id</p>"},{"title":"Router#indexOf","link":"<a href=\"Router.html#indexOf\">indexOf</a>","description":"<p>Returns the bucket index of the given node id</p>"},{"title":"Router#length","link":"<a href=\"Router.html#length\">length</a>","description":"<p>Returns the total buckets in the routing table</p>"},{"title":"Router#removeContactByNodeId","link":"<a href=\"Router.html#removeContactByNodeId\">removeContactByNodeId</a>","description":"<p>Removes the contact from the routing table given a node id</p>"},{"title":"Router#size","link":"<a href=\"Router.html#size\">size</a>","description":"<p>Returns the total contacts in the routing table</p>"},{"title":"module:kadence/constants","link":"<a href=\"module-kadence_constants.html\">kadence/constants</a>"},{"title":"module:kadence/constants~ALPHA","link":"<a href=\"module-kadence_constants.html#~ALPHA\">ALPHA</a>","description":"<p>Degree of parallelism</p>"},{"title":"module:kadence/constants~B","link":"<a href=\"module-kadence_constants.html#~B\">B</a>","description":"<p>Number of bits for nodeID creation</p>"},{"title":"module:kadence/constants~K","link":"<a href=\"module-kadence_constants.html#~K\">K</a>","description":"<p>Number of contacts held in a bucket</p>"},{"title":"module:kadence/constants~MAX_UNIMPROVED_REFRESHES","link":"<a href=\"module-kadence_constants.html#~MAX_UNIMPROVED_REFRESHES\">MAX_UNIMPROVED_REFRESHES</a>","description":"<p>Quit refreshing no improvement</p>"},{"title":"module:kadence/constants~T_EXPIRE","link":"<a href=\"module-kadence_constants.html#~T_EXPIRE\">T_EXPIRE</a>","description":"<p>Interval for expiring local data entries</p>"},{"title":"module:kadence/constants~T_REFRESH","link":"<a href=\"module-kadence_constants.html#~T_REFRESH\">T_REFRESH</a>","description":"<p>Interval for performing router refresh</p>"},{"title":"module:kadence/constants~T_REPLICATE","link":"<a href=\"module-kadence_constants.html#~T_REPLICATE\">T_REPLICATE</a>","description":"<p>Interval for replicating local data</p>"},{"title":"module:kadence/constants~T_REPUBLISH","link":"<a href=\"module-kadence_constants.html#~T_REPUBLISH\">T_REPUBLISH</a>","description":"<p>Interval for republishing data</p>"},{"title":"module:kadence/constants~T_RESPONSETIMEOUT","link":"<a href=\"module-kadence_constants.html#~T_RESPONSETIMEOUT\">T_RESPONSETIMEOUT</a>","description":"<p>Time to wait for RPC response</p>"},{"title":"module:kadence/utils","link":"<a href=\"module-kadence_utils.html\">kadence/utils</a>"},{"title":"module:kadence/utils.compareKeyBuffers","link":"<a href=\"module-kadence_utils.html#.compareKeyBuffers\">compareKeyBuffers</a>","description":"<p>Compare two buffers for sorting</p>"},{"title":"module:kadence/utils.getBucketIndex","link":"<a href=\"module-kadence_utils.html#.getBucketIndex\">getBucketIndex</a>","description":"<p>Calculate the index of the bucket that key would belong to</p>"},{"title":"module:kadence/utils.getDistance","link":"<a href=\"module-kadence_utils.html#.getDistance\">getDistance</a>","description":"<p>Calculate the distance between two keys</p>"},{"title":"module:kadence/utils.getPowerOfTwoBufferForIndex","link":"<a href=\"module-kadence_utils.html#.getPowerOfTwoBufferForIndex\">getPowerOfTwoBufferForIndex</a>","description":"<p>Returns a buffer with a power-of-two value given a bucket index</p>"},{"title":"module:kadence/utils.getRandomBufferInBucketRange","link":"<a href=\"module-kadence_utils.html#.getRandomBufferInBucketRange\">getRandomBufferInBucketRange</a>","description":"<p>Generate a random number within the bucket's range</p>"},{"title":"module:kadence/utils.getRandomKeyBuffer","link":"<a href=\"module-kadence_utils.html#.getRandomKeyBuffer\">getRandomKeyBuffer</a>","description":"<p>Returns a random valid key/identity as a buffer</p>"},{"title":"module:kadence/utils.getRandomKeyString","link":"<a href=\"module-kadence_utils.html#.getRandomKeyString\">getRandomKeyString</a>","description":"<p>Returns a random valid key/identity as a string</p>"},{"title":"module:kadence/utils.hash160","link":"<a href=\"module-kadence_utils.html#.hash160\">hash160</a>","description":"<p>Returns the RMD-160 hash of the input</p>"},{"title":"module:kadence/utils.hash256","link":"<a href=\"module-kadence_utils.html#.hash256\">hash256</a>","description":"<p>Returns the SHA-256 hash of the input</p>"},{"title":"module:kadence/utils.isHexaString","link":"<a href=\"module-kadence_utils.html#.isHexaString\">isHexaString</a>","description":"<p>Tests if a string is valid hex</p>"},{"title":"module:kadence/utils.keyBufferIsValid","link":"<a href=\"module-kadence_utils.html#.keyBufferIsValid\">keyBufferIsValid</a>","description":"<p>Determines if the given buffer key is valid</p>"},{"title":"module:kadence/utils.keyStringIsValid","link":"<a href=\"module-kadence_utils.html#.keyStringIsValid\">keyStringIsValid</a>","description":"<p>Determines if the given string key is valid</p>"},{"title":"module:kadence/utils.preventConvoy","link":"<a href=\"module-kadence_utils.html#.preventConvoy\">preventConvoy</a>","description":"<p>Wraps the supplied function in a pseudo-random length timeout to help\nprevent convoy effects. These occur when a number of processes need to use\na resource in turn. There is a tendency for such bursts of activity to\ndrift towards synchronization, which can be disasterous. In Kademlia all\nnodes are requird to republish their contents every hour (T_REPLICATE). A\nconvoy effect might lead to this being synchronized across the network,\nwhich would appear to users as the network dying every hour. The default\ntimeout will be between 0 and 30 minutes unless specified.</p>"},{"title":"module:kadence/utils.toBinaryStringFromBuffer","link":"<a href=\"module-kadence_utils.html#.toBinaryStringFromBuffer\">toBinaryStringFromBuffer</a>","description":"<p>Converts a buffer to a string representation of binary</p>"},{"title":"module:kadence/utils.validateStorageAdapter","link":"<a href=\"module-kadence_utils.html#.validateStorageAdapter\">validateStorageAdapter</a>","description":"<p>Validates the given object is a storage adapter</p>"}]}